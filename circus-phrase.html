<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>é¦¬æˆ²åœ˜ï¼šèªè©å¤§å†’éšª (é›£åº¦é¸æ“‡ç‰ˆ)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Klee+One:wght@600&display=swap" rel="stylesheet">
    
    <style>
        * { 
            box-sizing: border-box; 
            -webkit-user-select: none; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0; padding: 0;
            background-color: #000;
            font-family: "Klee One", "Press Start 2P", cursive;
            overflow: hidden; touch-action: none;
            color: white;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; width: 100vw;
        }

        #game-container {
            position: relative; width: 100%; height: 100%;
            aspect-ratio: 4/3; 
            max-height: 100vh; max-width: 100vw;
            background: #000;
            border: 4px solid #222;
            image-rendering: pixelated; 
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        canvas {
            display: block; width: 100%; height: 100%;
            background: #000;
        }

        /* ä»‹é¢å±¤ */
        .ui-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.85); z-index: 50;
            color: #fff;
        }
        .hidden { display: none !important; }

        h1 {
            font-family: "Press Start 2P", serif;
            font-size: 1.5rem; color: #f39c12; 
            text-shadow: 4px 4px #c0392b;
            margin-bottom: 20px; text-align: center; line-height: 1.5;
        }
        
        h2 {
            font-family: "Klee One", serif;
            color: #3498db;
            margin-bottom: 15px;
        }

        .btn {
            font-family: "Klee One", serif;
            padding: 10px 20px; font-size: 1.1rem; margin: 8px;
            border: 4px solid #fff; border-radius: 0;
            cursor: pointer; font-weight: bold; 
            background-color: #e74c3c; color: #fff;
            box-shadow: 4px 4px 0px #c0392b;
            text-transform: uppercase;
            width: 200px;
        }
        .btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px #c0392b; }
        .btn-secondary { background-color: #3498db; box-shadow: 4px 4px 0px #2980b9; }
        
        .btn-easy { background-color: #2ecc71; box-shadow: 4px 4px 0px #27ae60; }
        .btn-hard { background-color: #8e44ad; box-shadow: 4px 4px 0px #9b59b6; }

        .panel {
            background: #2c3e50; border: 4px solid #fff; padding: 20px;
            width: 90%; max-width: 500px; text-align: center;
            max-height: 85vh; overflow-y: auto;
        }
        
        textarea, input {
            padding: 10px; font-size: 1.2rem; width: 100%;
            background: #34495e; color: white; border: 2px solid #95a5a6;
            margin-bottom: 10px; font-family: "Klee One";
        }

        /* HUD */
        #hud-top {
            position: absolute; top: 10px; left: 5%; width: 90%;
            display: flex; justify-content: space-between; align-items: center;
            font-family: "Press Start 2P", monospace; font-size: 12px;
            z-index: 20; pointer-events: none;
            background: transparent; 
            color: #fff;
            letter-spacing: 1px;
            text-shadow: 2px 2px 0 #000;
        }
        
        #target-display-box {
            position: absolute; top: 16%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); 
            border: 2px solid #f1c40f; border-radius: 4px;
            padding: 4px 16px; text-align: center;
            z-index: 20;
        }
        #current-target-text {
            color: #f1c40f; font-size: 1.8rem; font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            font-family: "Klee One";
        }
        
        #controls-overlay {
            position: absolute; bottom: 40px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 30px;
            pointer-events: none; z-index: 30;
        }
        .control-btn {
            pointer-events: auto;
            width: 70px; height: 70px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.8rem; color: white;
            user-select: none;
        }
        .control-btn:active { background: rgba(241, 196, 15, 0.6); transform: scale(0.95); }
        
        /* åå¸è¨Šæ¯ (å–ä»£ alert) */
        #toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 2px;
            padding: 16px;
            position: fixed;
            z-index: 100;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            font-size: 1rem;
            border: 2px solid #f1c40f;
        }
        #toast.show { visibility: visible; -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s; animation: fadein 0.5s, fadeout 0.5s 2.5s; }
        
        @keyframes fadein { from {bottom: 0; opacity: 0;} to {bottom: 30px; opacity: 1;} }
        @keyframes fadeout { from {bottom: 30px; opacity: 1;} to {bottom: 0; opacity: 0;} }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="hud-top">
        <div>1P-<span id="score-val">000000</span></div>
        <div style="color:#f9ca24">HI-20000</div>
        <div>STAGE-01</div>
    </div>
    
    <div id="target-display-box">
        <div style="font-size:0.7rem; color:#ccc;">FIND:</div>
        <div id="current-target-text">?</div>
        <div id="lives-display" style="font-size:0.8rem; color:#e74c3c; margin-top:2px;">â¤ï¸â¤ï¸â¤ï¸</div>
    </div>

    <div id="controls-overlay">
        <div id="btn-duck" class="control-btn">â¬‡ï¸</div>
        <div id="btn-jump" class="control-btn">A</div>
    </div>

    <!-- æ•™å¸«ç«¯ / é è¨­ä¸»é¸å–® -->
    <div id="start-screen" class="ui-screen">
        <div style="font-size: 3rem; margin-bottom: 10px;">ğŸ¦ğŸªğŸ”¥</div>
        <h1>CIRCUS WORDS<br>èªè©ç«åœˆç‰ˆ</h1>
        <button class="btn" onclick="Game.setDifficulty('normal')">é–‹å§‹éŠæˆ² (é è¨­)</button>
        <button class="btn btn-secondary" onclick="Game.showTeacherPanel()">è€å¸«å‡ºé¡Œ SETUP</button>
        <div style="font-size: 0.9rem; color: #ddd; margin-top: 20px; line-height: 1.6; text-align: left; background:rgba(0,0,0,0.5); padding:10px;">
            <div style="color:#f1c40f">â— æ­£ç¢ºè©ï¼š</div> æŒ‰ <span style="border:1px solid white; padding:0 4px;">A</span> è·³èµ·ä¾†ï¼Œç©¿éç«åœˆåƒæ‰<br>
            <div style="color:#3498db; margin-top:5px;">â— éŒ¯èª¤è©ï¼š</div> æŒ‰ <span style="border:1px solid white; padding:0 4px;">â¬‡ï¸</span> è¶´ä¸‹ï¼Œå¾ç«åœˆä¸‹æ–¹é‘½é<br>
        </div>
    </div>

    <!-- å­¸ç”Ÿç«¯ï¼šé›£åº¦é¸æ“‡ç•«é¢ -->
    <div id="difficulty-screen" class="ui-screen hidden">
        <div style="font-size: 3rem; margin-bottom: 10px;">ğŸ¯</div>
        <h1>è«‹é¸æ“‡é›£åº¦</h1>
        
        <button class="btn btn-easy" onclick="Game.setDifficulty('easy')">ç°¡å–® EASY<br><span style="font-size:0.8rem">æ…¢é€Ÿ / 5å‘½</span></button>
        <button class="btn" onclick="Game.setDifficulty('normal')">æ™®é€š NORMAL<br><span style="font-size:0.8rem">ä¸­é€Ÿ / 3å‘½</span></button>
        <button class="btn btn-hard" onclick="Game.setDifficulty('hard')">å›°é›£ HARD<br><span style="font-size:0.8rem">å¿«é€Ÿ / 2å‘½</span></button>
        
        <div style="font-size: 0.9rem; color: #ddd; margin-top: 30px;">
            ç›®æ¨™ï¼š<span id="diff-target-preview" style="color:#f1c40f; font-weight:bold;">...</span>
        </div>
    </div>

    <div id="teacher-screen" class="ui-screen hidden">
        <div class="panel">
            <h2>ğŸª åœ˜é•·å‡ºé¡Œè¨­å®š (èªè©ç‰ˆ)</h2>
            
            <div style="text-align:left;">1. éŠæˆ²é™æ™‚ (ç§’)ï¼š</div>
            <input type="number" id="time-limit-input" value="120">
            
            <div style="text-align:left;">2. ç›®æ¨™èªè© (é€—è™Ÿåˆ†éš”)ï¼š</div>
            <textarea id="target-input" rows="4" placeholder="ä¾‹å¦‚ï¼šè˜‹æœ, é¦™è•‰, é³³æ¢¨">è˜‹æœ, é¦™è•‰, é³³æ¢¨, è¥¿ç“œ, è‘¡è„</textarea>
            
            <div style="text-align:left;">3. å¹²æ“¾èªè© (AIè‡ªå‹•è£œè¶³ï¼Œå¯è‡ªè¨‚)ï¼š</div>
            <textarea id="distractor-input" rows="3" placeholder="ä¾‹å¦‚ï¼šæ¡Œå­, æ¤…å­, æ›¸æœ¬..."></textarea>
            
            <button class="btn" onclick="Game.saveSettings()">å„²å­˜ SAVE</button>
            <button class="btn btn-secondary" onclick="Game.generateQR()">ç”¢ç”Ÿ QR Code</button>
            <div id="qr-area" style="margin-top:10px; display:none;">
                <img id="qr-img" style="border: 4px solid #fff; max-width:150px;">
            </div>
            <button class="btn btn-secondary" onclick="Game.showMenu()">è¿”å› BACK</button>
        </div>
    </div>

    <div id="game-over-screen" class="ui-screen hidden">
        <h1 style="color: #e74c3c">GAME OVER</h1>
        <div id="end-reason" style="margin-bottom: 20px; font-size:1.2rem;"></div>
        <div style="font-size: 1.2rem; margin-bottom: 20px;">SCORE: <span id="final-score">0</span></div>
        <button class="btn" onclick="Game.startGame()">å†ç©ä¸€æ¬¡ RETRY</button>
        <button class="btn btn-secondary" onclick="Game.showMenuOrDifficulty()">ä¸»é¸å–® MENU</button>
    </div>
    
    <div id="toast">è¨­å®šå·²å„²å­˜ï¼</div>
</div>

<script>
// å¸¸ç”¨èªè©åº« (ç”¨æ–¼è£œè¶³å¹²æ“¾é … - é›™å­—è©ç‚ºä¸»)
const COMMON_WORDS = [
    "å¤©ç©º", "ç™½é›²", "å¤ªé™½", "æœˆäº®", "æ˜Ÿæ˜Ÿ", "å½©è™¹", "ä¸‹é›¨",
    "å¿«æ¨‚", "ç”Ÿæ°£", "é›£é", "å®³æ€•", "ç·Šå¼µ", "èˆˆå¥®", "æ„Ÿå‹•",
    "çˆ¸çˆ¸", "åª½åª½", "è€å¸«", "åŒå­¸", "æœ‹å‹", "é†«ç”Ÿ", "è­¦å¯Ÿ",
    "ç´…è‰²", "è—è‰²", "ç¶ è‰²", "é»ƒè‰²", "é»‘è‰²", "ç™½è‰²", "ç´«è‰²",
    "æ¡Œå­", "æ¤…å­", "é›»è…¦", "æ›¸æœ¬", "é‰›ç­†", "æ©¡çš®", "æ™‚é˜",
    "å¯æ„›", "ç¾éº—", "å¸¥æ°£", "èªçœŸ", "åŠªåŠ›", "è°æ˜", "å¥åº·",
    "è·‘æ­¥", "æ¸¸æ³³", "è·³èˆ", "å”±æ­Œ", "ç•«ç•«", "çœ‹æ›¸", "ç¡è¦º",
    "å°ç‹—", "å°è²“", "å…”å­", "å¤§è±¡", "ç…å­", "è€è™", "ç†Šè²“",
    "æ±½è»Š", "ç«è»Š", "é£›æ©Ÿ", "å…¬è»Š", "å–®è»Š", "èˆ¹éš»", "ç«ç®­"
];

const PALETTE = {
    black: '#000000',
    blue: '#0040A0',       
    white: '#F8F8F8',      
    red: '#E40058',        
    green: '#00A800',      
    groundLine: '#005000', 
    lionBody: '#FC9838',   
    lionMane: '#AC7C00',   
    charlieSkin: '#FC9838',
    charlieSuit: '#FCFCFC',
    charlieRed: '#D82800', 
    fireInner: '#FCE4A0',  
    fireOuter: '#D82800',  
    rope: '#AC7C00',      
    elephantGray: '#999999',
    elephantWhite: '#FCFCFC'
};

const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: null,
    
    state: 'menu', 
    width: 0, height: 0,
    
    timeLimit: 120,
    timeLeft: 120,
    score: 0,
    lives: 3,
    mistakes: 0,
    mistakeMax: 3,
    
    targetList: ['è˜‹æœ', 'é¦™è•‰', 'é³³æ¢¨', 'è¥¿ç“œ', 'è‘¡è„'],
    distractorList: [],
    currentTargetIndex: 0,
    
    // éŠæˆ²è¨­å®šåƒæ•¸
    currentDifficulty: 'normal',
    config: {
        easy: { speed: 2.5, lives: 5 },
        normal: { speed: 3.5, lives: 3 },
        hard: { speed: 5.0, lives: 2 }
    },
    
    isStudentMode: false, // åˆ¤æ–·æ˜¯å¦ç‚ºå­¸ç”Ÿæƒç¢¼é€²å…¥
    
    successWord: null,
    
    player: {
        x: 60, y: 0, 
        w: 50, h: 40, 
        vy: 0, gravity: 0.55, jumpForce: -11.5,
        isGrounded: true,
        isDucking: false,
        spriteFrame: 0,
        runFrame: 0
    },
    
    obstacles: [], 
    bgOffset: 0,
    meterOffset: 0, 
    gameSpeed: 3.5,
    spawnTimer: 0,
    
    init() {
        this.ctx = this.canvas.getContext('2d');
        this.ctx.imageSmoothingEnabled = false; 
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        window.addEventListener('keydown', e => {
            if (e.code === 'Space' || e.key === 'ArrowUp' || e.code === 'KeyW' || e.key === 'a') this.triggerJump();
            if (e.key === 'ArrowDown' || e.code === 'KeyS') this.triggerDuck(true);
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'ArrowDown' || e.code === 'KeyS') this.triggerDuck(false);
        });

        const btnJump = document.getElementById('btn-jump');
        const btnDuck = document.getElementById('btn-duck');
        const bindTouch = (el, start, end) => {
            el.addEventListener('touchstart', (e) => { e.preventDefault(); start(); });
            el.addEventListener('touchend', (e) => { e.preventDefault(); end(); });
            el.addEventListener('mousedown', start);
            el.addEventListener('mouseup', end);
        };
        bindTouch(btnJump, () => this.triggerJump(), () => {});
        bindTouch(btnDuck, () => this.triggerDuck(true), () => this.triggerDuck(false));

        // é€™è£¡æª¢æŸ¥ URLï¼Œæ±ºå®šè¦é¡¯ç¤ºå“ªå€‹ç•«é¢
        this.checkURLParams();
        
        requestAnimationFrame(() => this.loop());
    },

    resize() {
        const c = document.getElementById('game-container');
        this.width = c.clientWidth;
        this.height = c.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        this.fenceY = this.height * 0.4;
        this.horizonY = this.height * 0.42; 
        this.groundY = this.height * 0.85;
    },

    triggerJump() {
        if (this.state !== 'playing') return;
        if (this.player.isGrounded && !this.player.isDucking) {
            this.player.vy = this.player.jumpForce;
            this.player.isGrounded = false;
            this.playSound('jump');
        }
    },

    triggerDuck(isDown) {
        if (this.state !== 'playing' && this.state !== 'success_pause') return;
        this.player.isDucking = isDown;
    },

    checkURLParams() {
        const p = new URLSearchParams(window.location.search);
        const w = p.get('words');
        const t = p.get('time');
        
        if (w) {
            // æœ‰åƒæ•¸ï¼Œä»£è¡¨æ˜¯å­¸ç”Ÿæƒç¢¼é€²å…¥
            this.isStudentMode = true;
            // èªè©ç‰ˆï¼šä½¿ç”¨é€—è™Ÿæˆ–ç©ºæ ¼åˆ†éš”
            this.targetList = decodeURIComponent(w).split(/[,ï¼Œã€\s]+/).filter(s => s.trim());
            document.getElementById('target-input').value = this.targetList.join(', ');
            document.getElementById('diff-target-preview').innerText = this.targetList.slice(0, 3).join('ã€') + (this.targetList.length > 3 ? '...' : '');
            
            // ç›´æ¥é¡¯ç¤ºé›£åº¦é¸æ“‡ç•«é¢ï¼Œè€Œä¸æ˜¯ä¸»é¸å–®
            this.toggleScreen('difficulty-screen');
        } else {
            // ç„¡åƒæ•¸ï¼Œæ•™å¸«ç«¯ï¼Œé¡¯ç¤ºä¸»é¸å–®
            this.isStudentMode = false;
            this.toggleScreen('start-screen');
        }
        
        if (t) this.timeLimit = parseInt(t);
    },

    setDifficulty(level) {
        this.currentDifficulty = level;
        this.startGame();
    },

    startGame() {
        // æ ¹æ“šé›£åº¦è¨­å®šåƒæ•¸
        const cfg = this.config[this.currentDifficulty];
        this.gameSpeed = cfg.speed;
        this.lives = cfg.lives;
        
        this.score = 0;
        this.mistakes = 0;
        this.timeLeft = this.timeLimit;
        this.currentTargetIndex = 0;
        this.prepareDistractors();
        
        this.player.y = this.groundY;
        this.player.vy = 0;
        this.player.isGrounded = true;
        this.obstacles = [];
        this.spawnTimer = 0;
        this.successWord = null;
        
        this.state = 'playing';
        this.toggleScreen('');
        this.updateHUD();
        this.speakCurrentTarget();
        
        if (this.gameTimer) clearInterval(this.gameTimer);
        this.gameTimer = setInterval(() => {
            if (this.state === 'playing') {
                this.timeLeft--;
                if (this.timeLeft <= 0) this.die("æ™‚é–“åˆ°ï¼");
                this.updateHUD();
            }
        }, 1000);
    },

    prepareDistractors() {
        let rawManual = document.getElementById('distractor-input').value;
        // èªè©ç‰ˆï¼šåˆ†å‰²é‚è¼¯
        let manual = rawManual.split(/[,ï¼Œã€\s]+/).filter(s => s.trim());
        
        this.distractorList = [...manual];
        // è£œè¶³åˆ° 25 å€‹è©
        while (this.distractorList.length < 25) {
            let w = COMMON_WORDS[Math.floor(Math.random() * COMMON_WORDS.length)];
            if (!this.targetList.includes(w) && !this.distractorList.includes(w)) {
                this.distractorList.push(w);
            }
        }
    },

    spawnObstacle() {
        if (this.spawnTimer <= 0) {
            let isTarget = Math.random() < 0.6;
            const targetWord = this.targetList[this.currentTargetIndex];
            
            let distractor = this.distractorList[Math.floor(Math.random() * this.distractorList.length)];
            while(distractor === targetWord) {
                 distractor = this.distractorList[Math.floor(Math.random() * this.distractorList.length)];
            }
            
            let text = isTarget ? targetWord : distractor;

            const radiusX = 45; 
            const radiusY = 70; 
            const safeGap = 35;
            const ringCenterY = this.groundY - safeGap - radiusY;
            
            this.obstacles.push({
                x: this.width + 80,
                y: ringCenterY,
                radiusX: radiusX, 
                radiusY: radiusY, 
                text: text,
                isTarget: isTarget,
                eaten: false,
                fireFrame: 0 
            });

            // æ ¹æ“šé›£åº¦å¾®èª¿ç”Ÿæˆé »ç‡ (è¶Šé›£è¶Šå¯†é›†ä¸€é»)
            let baseSpawn = 150;
            if (this.currentDifficulty === 'hard') baseSpawn = 110;
            if (this.currentDifficulty === 'easy') baseSpawn = 180;
            
            this.spawnTimer = Math.floor(Math.random() * 80) + baseSpawn;
        }
        this.spawnTimer--;
    },

    update() {
        if (this.state === 'success_pause') return;
        if (this.state !== 'playing') return;

        if (!this.player.isGrounded) {
            this.player.vy += this.player.gravity;
            this.player.y += this.player.vy;
            if (this.player.y >= this.groundY) {
                this.player.y = this.groundY;
                this.player.isGrounded = true;
                this.player.vy = 0;
            }
        }
        
        if (this.player.isGrounded) {
            if (Date.now() % 150 < 75) this.player.runFrame = 0;
            else this.player.runFrame = 1;
        }

        this.spawnObstacle();

        this.bgOffset = (this.bgOffset + this.gameSpeed * 0.3) % 120; 
        this.meterOffset = (this.meterOffset + this.gameSpeed) % 60; 
        
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            let ob = this.obstacles[i];
            ob.x -= this.gameSpeed;
            if (Date.now() % 100 < 50) ob.fireFrame = 0; else ob.fireFrame = 1;

            if (ob.x < -100) {
                this.obstacles.splice(i, 1);
                continue;
            }

            // --- ç¢°æ’æª¢æ¸¬ ---
            if (Math.abs(this.player.x - ob.x) < 20) {
                const ringBottom = ob.y + ob.radiusY - 8; 
                const ringTop = ob.y - ob.radiusY + 8;    
                
                const playerHeight = this.player.isDucking ? 25 : 50;
                const playerTop = this.player.y - playerHeight;
                const playerBottom = this.player.y;

                if (this.player.isDucking) {
                    if (playerTop > ringBottom) {
                        // Safe
                    } else {
                         this.handleCrash("æ’åˆ°ç«åœˆï¼");
                    }
                } else {
                    if (this.player.isGrounded) {
                         this.handleCrash("æ²’è·³ä¹Ÿæ²’è¶´ä¸‹ï¼");
                    } else {
                        if (playerTop < ringTop || playerBottom > ringBottom) {
                             this.handleCrash("æ’åˆ°ç«åœˆé‚Šç·£ï¼");
                        } else {
                            if (!ob.eaten) {
                                ob.eaten = true;
                                this.handleWordCollision(ob);
                            }
                        }
                    }
                }
            }
        }
    },

    handleWordCollision(ob) {
        if (ob.isTarget) {
            this.score += 500;
            this.playSound('good');
            
            this.state = 'success_pause';
            this.successWord = ob.text;
            
            this.speak(ob.text, () => {
                this.state = 'playing';
                this.successWord = null;
                
                this.currentTargetIndex++;
                if (this.currentTargetIndex >= this.targetList.length) {
                    this.currentTargetIndex = 0;
                    // å®Œæˆä¸€è¼ªå¾Œï¼Œé€Ÿåº¦å¾®å¹…å¢åŠ 
                    this.gameSpeed = Math.min(this.gameSpeed + 0.3, 8);
                }
                this.speakCurrentTarget();
                this.updateHUD();
            });

        } else {
            this.handleMistake("åƒåˆ°å¹²æ“¾è©ï¼");
        }
        this.updateHUD();
    },

    handleMistake(reason) {
        this.playSound('bad');
        this.mistakes++;
        
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.top = '0'; overlay.style.left = '0';
        overlay.style.width = '100%'; overlay.style.height = '100%';
        overlay.style.background = 'rgba(228, 0, 88, 0.4)';
        overlay.style.zIndex = '100';
        document.getElementById('game-container').appendChild(overlay);
        setTimeout(() => overlay.remove(), 100);

        if (this.mistakes >= this.mistakeMax) {
            this.mistakes = 0;
            this.lives--;
            if (this.lives <= 0) this.die("ç”Ÿå‘½è€—ç›¡");
        }
        this.updateHUD();
    },

    handleCrash(reason) {
        if (this.state === 'dead') return;
        this.playSound('crash');
        this.lives--;
        this.updateHUD();
        this.state = 'dead';
        
        let count = 0;
        let blink = setInterval(() => {
            count++;
            this.ctx.fillStyle = count % 2 === 0 ? PALETTE.black : 'transparent';
            this.ctx.fillRect(0,0,this.width, this.height);
            
            if (count > 6) {
                clearInterval(blink);
                if (this.lives <= 0) {
                    this.die(reason);
                } else {
                    this.obstacles = this.obstacles.filter(o => o.x > this.width + 200);
                    this.state = 'playing';
                    this.player.y = this.groundY;
                    this.player.vy = 0;
                    this.player.isGrounded = true;
                }
            }
        }, 100);
    },

    die(reason) {
        this.state = 'gameover';
        clearInterval(this.gameTimer);
        document.getElementById('end-reason').innerText = reason;
        document.getElementById('final-score').innerText = this.score;
        this.toggleScreen('game-over-screen');
    },

    draw() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;

        ctx.fillStyle = PALETTE.black;
        ctx.fillRect(0, 0, w, h);
        
        this.drawTentTop(ctx);
        this.drawAudience(ctx);
        this.drawElephant(ctx, 0, this.fenceY - 80, true); 
        this.drawElephant(ctx, this.width - 70, this.fenceY - 80, false); 
        this.drawGround(ctx);
        this.drawBottomMeter(ctx);

        this.obstacles.forEach(ob => {
            this.drawRingBack(ctx, ob);
        });

        if (this.state !== 'dead' || Date.now() % 200 < 100) {
            this.drawPlayer(ctx);
        }
        
        this.obstacles.forEach(ob => {
            this.drawRingFront(ctx, ob);
            this.drawRingText(ctx, ob); 
        });

        if (this.state === 'success_pause' && this.successWord) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, w, h);
            
            ctx.save();
            ctx.translate(w/2, h/2);
            
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 4;
            // èªè©ç‰ˆæ¡†æ¡†åŠ å¯¬
            ctx.strokeRect(-120, -80, 240, 160);
            ctx.fillStyle = '#222';
            ctx.fillRect(-120, -80, 240, 160);
            
            ctx.fillStyle = '#f1c40f'; 
            // èªè©ç‰ˆå­—é«”é©ä¸­
            ctx.font = "bold 60px 'Klee One'";
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.successWord, 0, 0);
            
            ctx.fillStyle = '#FFF';
            ctx.font = "16px 'Press Start 2P'";
            ctx.fillText("GREAT!", 0, -100);
            
            ctx.restore();
        }
    },

    drawTentTop(ctx) {
        const tentHeight = this.height * 0.15; 
        const stripeWidth = 20; 
        
        ctx.fillStyle = PALETTE.red;
        ctx.fillRect(0, tentHeight - 8, this.width, 8);

        for (let x = 0; x < this.width; x += stripeWidth) {
            ctx.fillStyle = (Math.floor(x / stripeWidth) % 2 === 0) ? PALETTE.red : PALETTE.white;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x + stripeWidth, 0);
            ctx.lineTo(x + stripeWidth/2, tentHeight);
            ctx.fill();
        }
    },

    drawElephant(ctx, x, y, isLeft) {
        const s = 3; 
        const bodyColor = PALETTE.elephantGray;
        const tuskColor = PALETTE.elephantWhite;

        ctx.save();
        ctx.translate(x, y);

        if (!isLeft) { 
            ctx.scale(-1, 1);
            ctx.translate(-70, 0); 
        }

        ctx.fillStyle = bodyColor;
        ctx.fillRect(0, 10*s, 18*s, 12*s); 
        ctx.fillRect(12*s, 5*s, 10*s, 12*s);
        ctx.fillRect(8*s, 4*s, 6*s, 8*s);
        ctx.fillStyle = PALETTE.black;
        ctx.fillRect(16*s, 7*s, 2*s, 2*s);
        ctx.fillStyle = tuskColor;
        ctx.beginPath();
        ctx.moveTo(18*s, 12*s);
        ctx.lineTo(24*s, 10*s);
        ctx.lineTo(20*s, 14*s);
        ctx.fill();
        ctx.fillStyle = bodyColor;
        ctx.fillRect(20*s, 12*s, 4*s, 8*s);
        ctx.fillRect(22*s, 18*s, 3*s, 4*s); 
        ctx.fillStyle = PALETTE.red;
        ctx.fillRect(4*s, 10*s, 8*s, 4*s);
        ctx.fillStyle = PALETTE.blue;
        ctx.fillRect(5*s, 11*s, 6*s, 2*s);

        ctx.restore();
    },

    drawAudience(ctx) {
        const startY = 50; 
        const endY = this.fenceY;
        const patternH = 16; 
        
        for (let y = startY; y < endY - 20; y += patternH) {
            let rowType = Math.floor((y - startY) / patternH) % 3;
            let color = rowType === 0 ? PALETTE.blue : (rowType === 1 ? PALETTE.red : PALETTE.white);
            let shift = -(this.bgOffset * 0.5) % 24; 
            
            ctx.fillStyle = color;
            for (let x = shift; x < this.width; x += 24) { 
                if (x > -10) {
                    ctx.fillRect(x, y, 4, 4);
                    ctx.fillRect(x + 6, y, 4, 4); 
                }
            }
        }

        ctx.fillStyle = PALETTE.white;
        ctx.fillRect(0, endY - 15, this.width, 4);
        
        const fenceH = this.horizonY - (endY - 10);
        ctx.fillStyle = PALETTE.blue;
        ctx.fillRect(0, endY - 10, this.width, fenceH);
        
        ctx.fillStyle = '#002060'; 
        for (let x = - (this.bgOffset % 40); x < this.width; x += 40) {
            ctx.beginPath();
            ctx.moveTo(x + 20, endY - 10);
            ctx.lineTo(x + 40, endY - 10 + fenceH/2);
            ctx.lineTo(x + 20, endY - 10 + fenceH);
            ctx.lineTo(x, endY - 10 + fenceH/2);
            ctx.fill();
        }
    },

    drawGround(ctx) {
        ctx.fillStyle = PALETTE.green;
        ctx.fillRect(0, this.horizonY, this.width, this.height - this.horizonY - 40); 
        
        const groundH = this.height - this.horizonY - 40;
        
        ctx.fillStyle = PALETTE.groundLine;
        ctx.fillRect(0, this.horizonY + groundH * 0.2, this.width, 2);
        ctx.fillRect(0, this.horizonY + groundH * 0.5, this.width, 2);
    },

    drawBottomMeter(ctx) {
        const h = 40;
        const y = this.height - h;
        
        ctx.fillStyle = PALETTE.red;
        ctx.fillRect(0, y, this.width, h);
        
        ctx.fillStyle = PALETTE.white;
        const dotY = y + h/2 - 2;
        const spacing = 100;
        for (let x = -(this.meterOffset * 1.5) % spacing; x < this.width; x += spacing) {
            if (x > -20) {
                ctx.fillRect(x, dotY, 6, 6);
                ctx.fillRect(x + spacing/2, dotY + 1, 4, 4);
                
                if (Math.floor(x) % (spacing*2) === 0) {
                    ctx.fillStyle = PALETTE.black;
                    ctx.font = '10px "Press Start 2P"';
                    ctx.fillText(((x+100)/10).toFixed(0) + "m", x - 10, y + 30);
                    ctx.fillStyle = PALETTE.white;
                }
            }
        }
        
        ctx.fillStyle = PALETTE.lionBody;
        ctx.fillRect(20, y + 10, 16, 16); 
    },

    drawRingBack(ctx, ob) {
        this.drawFireRing(ctx, ob.x, ob.y, ob.radiusX, ob.radiusY, ob.fireFrame, true);
        
        ctx.strokeStyle = PALETTE.rope;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(ob.x, 0);
        ctx.lineTo(ob.x, ob.y - ob.radiusY + 5);
        ctx.stroke();
    },

    drawRingFront(ctx, ob) {
        this.drawFireRing(ctx, ob.x, ob.y, ob.radiusX, ob.radiusY, ob.fireFrame, false);
    },

    drawFireRing(ctx, cx, cy, rx, ry, frame, isBack) {
        const count = 16; 
        const angleStep = (Math.PI * 2) / count;
        
        for (let i = 0; i < count; i++) {
            const angle = i * angleStep;
            
            const px = cx + Math.cos(angle) * rx;
            const py = cy + Math.sin(angle) * ry;
            
            const isUpper = (angle > Math.PI && angle < Math.PI * 2);
            
            if (isBack && !isUpper) continue;
            if (!isBack && isUpper) continue;

            this.drawFireSprite(ctx, px, py, (i + frame) % 2);
        }
    },
    
    drawFireSprite(ctx, x, y, variant) {
        const size = 3; 
        
        ctx.fillStyle = PALETTE.fireOuter; 
        if (variant === 0) {
            ctx.fillRect(x - size*2, y - size*2, size*4, size*4);
        } else {
            ctx.fillRect(x - size*1.5, y - size*3, size*3, size*6);
        }
        
        ctx.fillStyle = PALETTE.fireInner; 
        ctx.fillRect(x - size, y - size, size*2, size*2);
    },

    drawRingText(ctx, ob) {
        if (ob.eaten) return;
        
        const bx = ob.x;
        const by = ob.y; 
        
        ctx.fillStyle = '#FFF';
        // èªè©ç‰ˆå­—é«”ï¼š24px
        ctx.font = "bold 24px 'Klee One'";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 4;
        ctx.strokeText(ob.text, bx, by);
        ctx.fillText(ob.text, bx, by);
    },

    drawPlayer(ctx) {
        const p = this.player;
        const x = p.x;
        const y = p.y; 
        const s = 3; 

        ctx.save();
        ctx.translate(x, y);

        const frame = p.runFrame; 
        const tailY = Math.sin(Date.now() / 100) * 2;

        if (p.isDucking) {
            ctx.fillStyle = PALETTE.lionBody;
            ctx.fillRect(-15, -15, 45, 15); 
            ctx.fillStyle = PALETTE.lionMane;
            ctx.fillRect(25, -20, 10, 15); 
            
            ctx.fillStyle = PALETTE.charlieSuit;
            ctx.fillRect(-5, -22, 25, 8);
        } else if (!p.isGrounded) {
            ctx.fillStyle = PALETTE.lionBody;
            ctx.fillRect(-12*s, -10*s, 16*s, 8*s); 
            
            ctx.fillRect(-10*s, -2*s, 4*s, 4*s); 
            ctx.fillRect(0*s, -4*s, 6*s, 4*s);   
            
            ctx.fillStyle = PALETTE.lionMane;
            ctx.fillRect(4*s, -12*s, 6*s, 8*s);
            
            ctx.strokeStyle = PALETTE.lionBody;
            ctx.lineWidth = s;
            ctx.beginPath();
            ctx.moveTo(-12*s, -8*s);
            ctx.lineTo(-16*s, -12*s);
            ctx.stroke();

            this.drawCharlie(ctx, 0, -16*s, s);

        } else {
            ctx.fillStyle = PALETTE.lionBody;
            ctx.fillRect(-10*s, -11*s, 18*s, 8*s);
            
            ctx.fillStyle = PALETTE.lionBody;
            if (frame === 0) {
                ctx.fillRect(-10*s, -3*s, 3*s, 3*s); 
                ctx.fillRect(5*s, -3*s, 3*s, 3*s);   
            } else {
                ctx.fillRect(-6*s, -3*s, 3*s, 3*s);  
                ctx.fillRect(0*s, -3*s, 3*s, 3*s);   
            }

            ctx.fillStyle = PALETTE.lionMane;
            ctx.fillRect(6*s, -14*s, 7*s, 9*s);
            
            ctx.fillStyle = PALETTE.lionBody;
            ctx.fillRect(11*s, -13*s, 4*s, 5*s);
            ctx.fillStyle = 'red';
            ctx.fillRect(13*s, -9*s, 2*s, 1*s);

            ctx.strokeStyle = PALETTE.lionBody;
            ctx.lineWidth = s;
            ctx.beginPath();
            ctx.moveTo(-10*s, -10*s);
            ctx.lineTo(-14*s, -12*s + tailY);
            ctx.stroke();

            this.drawCharlie(ctx, -2*s, -17*s, s);
        }

        ctx.restore();
    },

    drawCharlie(ctx, x, y, s) {
        ctx.fillStyle = PALETTE.charlieSuit;
        ctx.fillRect(x, y, 6*s, 6*s);
        ctx.fillStyle = PALETTE.charlieRed;
        ctx.fillRect(x, y + 4*s, 6*s, 2*s); 
        ctx.fillRect(x + 2*s, y, 2*s, 6*s); 
        
        ctx.fillStyle = PALETTE.charlieSkin;
        ctx.fillRect(x + 1*s, y - 3*s, 4*s, 3*s);
        
        ctx.fillStyle = PALETTE.charlieRed;
        ctx.beginPath();
        ctx.moveTo(x + 1*s, y - 3*s);
        ctx.lineTo(x + 5*s, y - 3*s);
        ctx.lineTo(x + 3*s, y - 6*s);
        ctx.fill();
        
        ctx.strokeStyle = PALETTE.charlieSkin;
        ctx.lineWidth = s;
        ctx.beginPath();
        ctx.moveTo(x + 4*s, y + 2*s);
        ctx.lineTo(x + 8*s, y + 4*s);
        ctx.stroke();
    },

    updateHUD() {
        document.getElementById('score-val').innerText = this.score.toString().padStart(6, '0');
        document.getElementById('lives-display').innerText = 'â¤ï¸'.repeat(Math.max(0, this.lives));
        document.getElementById('current-target-text').innerText = this.targetList[this.currentTargetIndex];
    },

    playSound(type) {
        if (!window.AudioContext && !window.webkitAudioContext) return;
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        const now = ctx.currentTime;

        if (type === 'jump') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(300, now + 0.1);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'good') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.setValueAtTime(900, now + 0.1);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'crash' || type === 'bad') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(120, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        }
    },

    speak(text, onEndCallback) {
        if (!('speechSynthesis' in window)) {
            if (onEndCallback) onEndCallback();
            return;
        }

        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'zh-TW';
        u.rate = 0.9; 
        
        let callbackCalled = false;
        
        const handleEnd = () => {
            if (!callbackCalled) {
                callbackCalled = true;
                if (onEndCallback) onEndCallback();
            }
        };

        u.onend = handleEnd;
        u.onerror = handleEnd; 

        setTimeout(handleEnd, 3000);

        window.speechSynthesis.speak(u);
    },
    
    speakCurrentTarget() {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance("è«‹æ‰¾ " + this.targetList[this.currentTargetIndex]);
            u.lang = 'zh-TW';
            window.speechSynthesis.speak(u);
        }
    },

    toggleScreen(id) {
        ['start-screen', 'teacher-screen', 'game-over-screen', 'difficulty-screen'].forEach(s => document.getElementById(s).classList.add('hidden'));
        if (id) document.getElementById(id).classList.remove('hidden');
    },
    showTeacherPanel() { this.toggleScreen('teacher-screen'); },
    showMenu() { this.toggleScreen('start-screen'); },
    
    // ç”¨æ–¼éŠæˆ²çµæŸå¾Œçš„æŒ‰éˆ•ï¼šå¦‚æœæ˜¯å­¸ç”Ÿæ¨¡å¼ï¼Œå›é›£åº¦é¸æ“‡ï¼›å¦å‰‡å›ä¸»é¸å–®
    showMenuOrDifficulty() {
        if (this.isStudentMode) {
            this.toggleScreen('difficulty-screen');
        } else {
            this.toggleScreen('start-screen');
        }
    },
    
    showToast(msg) {
        const x = document.getElementById("toast");
        x.innerText = msg;
        x.className = "show";
        setTimeout(function(){ x.className = x.className.replace("show", ""); }, 3000);
    },
    
    saveSettings() {
        const t = document.getElementById('target-input').value;
        const time = document.getElementById('time-limit-input').value;
        if (t.trim()) {
            // èªè©ç‰ˆï¼šåˆ†å‰²é‚è¼¯
            this.targetList = t.split(/[,ï¼Œã€\s]+/).filter(x => x);
            
            this.timeLimit = parseInt(time) || 120;
            this.showToast("è¨­å®šå·²å„²å­˜ï¼");
            setTimeout(() => this.showMenu(), 1000);
        } else {
            this.showToast("è«‹è¼¸å…¥ç›®æ¨™èªè©ï¼");
        }
    },
    generateQR() {
        const t = document.getElementById('target-input').value.replace(/\s/g, '');
        const url = `${window.location.origin}${window.location.pathname}?words=${encodeURIComponent(t)}&time=${this.timeLimit}`;
        document.getElementById('qr-area').style.display = 'block';
        document.getElementById('qr-img').src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(url)}`;
    },
    
    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

window.onload = () => Game.init();
</script>
</body>
</html>
